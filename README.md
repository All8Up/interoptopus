
[![Latest Version]][crates.io]
[![docs]][docs.rs]
![MIT]

# Interoptopus ‚Äî ü¶Ä  ‚Üí  üêô ‚Üí  Python, C#, C, ...

Create FFI bindings to your favorite language. Composable. Escape hatches included.


## Overview

If you ...

- wrote an `extern "C"` API in Rust
- need C#, Python, C, ... bindings to your library, all at the same time
- prefer having fine-grained control over your API and interop generation
- would like to use some QoL [patterns](crate::patterns) in both Rust and your target language (e.g., [options](crate::patterns::option), [slices](crate::patterns::slice), '[classes](crate::patterns::class)') where feasible
- possibly want to create your own bindings for a not-yet supported language
- prefer to keep all your binding-related information (e.g., documentation) in Rust code

... then Interoptopus might be for you.


## Known limitations

- not yet used in production
- somewhat verbose if you don't own most of your types (still possible, just more work)
- if you target only a single language and don't care about your FFI layer other solutions might be better


## Supported Languages

| Language | Crate | Comment |
| --- | --- | --- |
| C# (incl. Unity) | [**interoptopus_backend_csharp**](https://crates.io/crates/interoptopus_backend_csharp) |  Built-in. |
| C | [**interoptopus_backend_c**](https://crates.io/crates/interoptopus_backend_c) | Built-in. |
| Python [CFFI](https://cffi.readthedocs.io/en/latest/index.html) | [**interoptopus_backend_cpython_cffi**](https://crates.io/crates/interoptopus_backend_cpython_cffi) | Built-in. |
| Your language | Write your own backend! | See existing backends for what to do.* |

(*) Ok, right now I don't really recommend writing a new backend just yet as lots of internals might change. That said, it should only take a few hours and feedback is more than welcome.



## Example

Slightly abridged, see the `examples/hello_world` for full code:

```rust
use interoptopus::{ffi_function, ffi_type};

#[ffi_type]
#[repr(C)]
pub struct Vec2f32 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

/// A function which does something with the vector.
#[ffi_function]
#[no_mangle]
pub extern "C" fn my_game_function(input: Option<&Vec2f32>) -> Vec2f32 {
    Vec2f32 { x: 2.0, y: 4.0, z: 6.0 }
}

// This ultimately defines our FFI exports, all functions have to be listed here.
interoptopus::inventory_function!(ffi_inventory, [], [my_game_function], []);
```

Generated by this code:

```ignore
#[test]
fn generate_csharp_bindings() {
    use interoptopus_backend_csharp::{Generator, InteropCSharp, Config};

    Generator::new(Config::default(), ffi_inventory()).write_to("Interop.cs")
}
```

With a Cargo.toml:

```toml
[dependencies]
interoptopus = { version = "0.1", features = ["derive"] }
interoptopus_backend_csharp = "0.1"
```


Will produce:

```cs
using System;
using System.Runtime.InteropServices;

namespace My.Company
{
    public static class InteropClass
    {
        public const string NativeLib = "hello_world";

        /// A function which does something with the vector.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "my_game_function")]
        public static extern Vec2f32 my_game_function(ref Vec2f32 input);
    }

    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Vec2f32
    {
        public float x;
        public float y;
        public float z;
    }
}
```

For other languages (Python, C, ...) see [**examples**](https://github.com/ralfbiedert/interoptopus/tree/master/examples/complex/bindings).

## Current Status

- June 13, 2021 - Pre-alpha. Has generated C#, C, Python-CFFI bindings at least once, many things missing, untested.



## FAQ

- **Why do I get `error[E0658]: macro attributes in #[derive] output are unstable`?**

    This happens when `#[ffi_type]` appears after `#derive[...]`. Just switch their order.


- **How do I support a new language?**

    1) create a new crate, like `my_language`
    1) check which existing backend comes closest, copy that code
    1) start from trait `Interop::write_to` producing some output, fix errors as they appear
    1) create a UI test against `interoptopus_reference_project` to ensure your bindings are stable


## Safety, Soundness, Undefined Behavior

This library naturally does "unsafe" things and any journey into FFI-land is a little adventure.
That said, here are some assumptions and quality standards this project is based on:

- Safe Rust calling safe Rust code must always be sound, with soundness boundaries
on the module level, although smaller scopes are preferred. For example, creating a `FFISlice`
from Rust and directly using it from Rust must never cause UB.

- We must never willingly generate broken bindings; that is, bindings which
"cannot be used correctly" (e.g., map a `u8` to a `float`). That said
there are situations where the soundness of a binding invocation depends on conditions outside
our control. In these cases we will trust foreign code will invoke the generated functions
correctly. For example, if a function is called with an `AsciiPointer` type we consider it _safe and sound_
to obtain a `str` from this pointer as `AsciiPointer`'s contract specifies it must point to
ASCII data. <sup>1</sup>

- Related to the previous point we generally assume functions and types on the other side will be used _appropriately_.
In particular, but not limited to:
    - passed references must always point to valid data,
    - Options to references may also be `null`,
    - FFI code respects any declared or required thread safety and it is up to the developer to ensure and communicate these,
    - the host process doesn't do anything that would be considered "bad taste" w.r.t. Rust's owned memory,
    - all `#[repr()]`, `extern "C"` and `#[no_mangle]` attributes have been applied correctly by the developer.

    It is your responsibility to communicate and / or uphold these conditions in your documenation and wrapping code.

    In summary, these points do not try to impose _additional_ requirements, they merely state
    conditions you would have to uphold _in any case_ had you written your own bindings
    for the functions and types involved.

- Any `unsafe` code in any abstraction we provide should be "well contained", properly documented
and reasonably be auditable.

- If 'unsound bindings' were ever needed (e.g., because of a lack of Rust specification,
like 'safely' mapping a trait's vtable) such bindings should be gated behind a feature flag
(e.g., `unsound`) and only enabled via an explicit opt-in.

<sup>1</sup> The reason for not declaring such potential contract violations `unsafe` is that,
in our opinon, nothing would be gained from doing so. If we assume some contracts could be
broken then any contract can be broken, including contracts essential to Rust's
machine abstraction (e.g., nothing can stop C from writing 100 additional bytes before and after
that ASCII pointer and there is no way to detect it from Rust). In other words, for Rust embedded
as a C library the _entire code base_ already executes under the latent threat of UB.


## Contributing

PRs are welcome. Bug fixes can be submitted directly, major changes should be filed as issues
first.

(Not active yet) Anything that would make previously working bindings change behavior or stop compiling
is a major change; which doesn't mean we're opposed to breaking stuff before 1.0, just that
we'd like to talk about it before it happens.

Also, please read the next section.


## License

[MIT](https://opensource.org/licenses/MIT)

This license only applies to code **in** this repository, not code generated **by** this repository. We do not claim copyright for code produced by backends included here; even if said code was based on a template from this repository.

For the avoidance of doubt, anything produced by `Interop::write_to` or any item emitted by a proc macro is considered "generated by".

[Latest Version]: https://img.shields.io/crates/v/interoptopus.svg
[crates.io]: https://crates.io/crates/interoptopus
[MIT]: https://img.shields.io/badge/license-MIT-blue.svg
[docs]: https://docs.rs/interoptopus/badge.svg
[docs.rs]: https://docs.rs/interoptopus/
