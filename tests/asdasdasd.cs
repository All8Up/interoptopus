// Automatically generated by Interoptopus.

// Debug - write_imports 
#pragma warning disable 0105
using System;
using System.Text;
using System.Reflection;
using System.Linq.Expressions;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.CompilerServices;
using My.Company;
#pragma warning restore 0105

// Debug - write_namespace_context 
namespace My.Company
{
    // Debug - write_class_context 
    public static partial class Interop
    {
        // Debug - write_native_lib_string 
        public const string NativeLib = "library";

        // Debug - write_abi_guard 
        static Interop()
        {
        }


        // Debug - write_function 
        /// Has documentation
        [LibraryImport(NativeLib, EntryPoint = "f")]
        // Debug - write_function_declaration 
        public static partial void f(Foo y);
        // Debug - write_function_overload 

        /// Has documentation
        public static unsafe void f(FooDelegate y)
        {
            var y_wrapped = new Foo(y);
            f(y_wrapped);;
        }

    }

    // Debug - write_pattern_slice 
    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceU8 : IEnumerable<byte>, IDisposable
    {
        byte[] _managed;
        IntPtr _data;
        ulong _len;
        bool _wePinned;

        public int Count => _managed?.Length ?? (int)_len;

        public unsafe ReadOnlySpan<byte> ReadOnlySpan
        {
            get
            {
                if (_managed is not null)
                {
                    return new ReadOnlySpan<byte>(_managed);
                }
                return new ReadOnlySpan<byte>(_data.ToPointer(), (int)_len);
            }
        }

        public unsafe byte this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                if (_managed is not null)
                {
                    return _managed[i];
                }
                return Unsafe.Read<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()));
            }
        }

        public SliceU8(GCHandle handle, ulong count)
        {
            _data = handle.AddrOfPinnedObject();
            _len = count;
        }

        public SliceU8(IntPtr handle, ulong count)
        {
            _data = handle;
            _len = count;
        }

        public SliceU8(byte[] managed)
        {
            _managed = managed;
            _data = GCHandle.Alloc(managed, GCHandleType.Pinned).AddrOfPinnedObject();
            _len = (ulong) managed.Length;
            _wePinned = true;
        }

        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i)
            {
                yield return this[i];
            }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_wePinned && _data != IntPtr.Zero)
            {
                Marshal.FreeHGlobal(_data);
                _data = IntPtr.Zero;
            }
            _managed = null;
        }

        [CustomMarshaller(typeof(SliceU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceU8 Managed()
            {
                return new SliceU8(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceU8 managed;
            private Unmanaged native;
            private Unmanaged sourceNative;
            private GCHandle? pinned;
            private SliceU8 marshalled;

            public void FromManaged(SliceU8 managed) { this.managed = managed; }
            public Unmanaged ToUnmanaged() => new Unmanaged { Data = managed._data, Len = managed._len };
            public void FromUnmanaged(Unmanaged unmanaged) { sourceNative = unmanaged; }
            public unsafe SliceU8 ToManaged() => new SliceU8(sourceNative.Data, sourceNative.Len);
            public void Free() { }
        }
    }

    // Debug - write_type_definition_named_callback 
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate byte FooNative(SliceU8.Unmanaged slice, IntPtr callback_data);
    public delegate byte FooDelegate(SliceU8 slice);

    [NativeMarshalling(typeof(MarshallerMeta))]
    public struct Foo : IDisposable
    {
        private FooDelegate _callbackUser;
        private IntPtr _callbackNative;

        public Foo() { }

        public Foo(FooDelegate callbackUser)
        {
            _callbackUser = callbackUser;
            _callbackNative = Marshal.GetFunctionPointerForDelegate(new FooNative(Call));
        }

        public byte Call(SliceU8.Unmanaged slice, IntPtr callback_data)
        {
            return _callbackUser(slice.Managed());
        }

        public void Dispose()
        {
            if (_callbackNative == IntPtr.Zero) return;
            Marshal.FreeHGlobal(_callbackNative);
            _callbackNative = IntPtr.Zero;
        }


        [CustomMarshaller(typeof(Foo), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr Callback;
            internal IntPtr Data;
        }


        public ref struct Marshaller
        {
            private Foo managed;
            private Unmanaged native;
            private Unmanaged sourceNative;
            private GCHandle? pinned;

            public void FromManaged(Foo managed)
            {
                this.managed = managed;
            }

            public Unmanaged ToUnmanaged()
            {
                return new Unmanaged
                {
                    Callback = managed._callbackNative,
                    Data = IntPtr.Zero
                };
            }

            public void FromUnmanaged(Unmanaged unmanaged)
            {
                sourceNative = unmanaged;
            }

            public Foo ToManaged()
            {
                return new Foo
                {
                    _callbackNative = sourceNative.Callback,
                };
            }

            public void Free() { }
        }
    }




}
