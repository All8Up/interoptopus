// Automatically generated by Interoptopus.

// Debug - write_imports 
#pragma warning disable 0105
using System;
using System.Text;
using System.Threading.Tasks;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.Marshalling;
using System.Runtime.CompilerServices;
using My.Company;
using My.Company.Common;
#pragma warning restore 0105

// Debug - write_namespace_context 
namespace My.Company.Common
{

    // Debug - write_type_definition_composite 
    public partial struct Vec
    {
        public double x;
        public double z;
    }

    // Debug - write_type_definition_composite_marshaller 
    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Vec
    {
        public Vec(Vec other)
        {
            x = other.x;
            z = other.z;
        }

        public Unmanaged ToUnmanaged()
        {
            var marshaller = new Marshaller(this);
            try { return marshaller.ToUnmanaged(); }
            finally { marshaller.Free(); }
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            // Debug - write_type_definition_composite_unmanaged_body_field 
            public double x;
            // Debug - write_type_definition_composite_unmanaged_body_field 
            public double z;

            public Vec ToManaged()
            {
                var marshaller = new Marshaller(this);
                try { return marshaller.ToManaged(); }
                finally { marshaller.Free(); }
            }
        }

        [CustomMarshaller(typeof(Vec), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private Vec _managed; // Used when converting managed -> unmanaged
            private Unmanaged _unmanaged; // Used when converting unmanaged -> managed

            public Marshaller(Vec managed) { _managed = managed; }
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public void FromManaged(Vec managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public unsafe Unmanaged ToUnmanaged()
            {;
                _unmanaged = new Unmanaged();

                // Debug - write_type_definition_composite_marshaller_unmanaged_invoke 
                _unmanaged.x = _managed.x;
                // Debug - write_type_definition_composite_marshaller_unmanaged_invoke 
                _unmanaged.z = _managed.z;

                return _unmanaged;
            }

            public unsafe Vec ToManaged()
            {
                _managed = new Vec();

                // Debug - write_type_definition_composite_marshaller_field_from_unmanaged 
                _managed.x = _unmanaged.x;
                // Debug - write_type_definition_composite_marshaller_field_from_unmanaged 
                _managed.z = _unmanaged.z;

                return _managed;
            }
            public void Free() { }
        }
    }

    // Debug - write_type_definition_fn_pointer 
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate byte InteropDelegate_fn_u8_rval_u8(byte x0);

    // Debug - write_type_definition_fn_pointer 
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void InteropDelegate_fn_CharArray(CharArray x0);
    public delegate void InteropDelegate_fn_CharArray_native(CharArray.Unmanaged x0);

    // Debug - write_pattern_fast_slice 
    public partial struct SliceBool
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceBool : IEnumerable<Bool>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<Bool> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe Bool this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<Bool>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<Bool>()));
            }

        }

        public SliceBool(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceBool(Bool[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<Bool> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceBool), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceBool ToManaged()
            {
                return new SliceBool(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceBool _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceBool managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceBool ToManaged()
            {
                _managed = new SliceBool();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceI32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceI32 : IEnumerable<int>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<int> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe int this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<int>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<int>()));
            }

        }

        public SliceI32(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceI32(int[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<int> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceI32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceI32 ToManaged()
            {
                return new SliceI32(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceI32 _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceI32 managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceI32 ToManaged()
            {
                _managed = new SliceI32();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceU32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceU32 : IEnumerable<uint>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<uint> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe uint this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<uint>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<uint>()));
            }

        }

        public SliceU32(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceU32(uint[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<uint> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceU32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceU32 ToManaged()
            {
                return new SliceU32(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceU32 _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceU32 managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceU32 ToManaged()
            {
                _managed = new SliceU32();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceU8
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceU8 : IEnumerable<byte>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<byte> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe byte this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()));
            }

        }

        public SliceU8(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceU8(byte[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceU8 ToManaged()
            {
                return new SliceU8(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceU8 _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceU8 managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceU8 ToManaged()
            {
                _managed = new SliceU8();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_marshalling_slice 
    public partial struct SliceUtf8String
    {
        string[] _managed;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceUtf8String : IEnumerable<string>, IDisposable
    {
        public int Count => _managed?.Length ?? (int) 0;

        public unsafe string this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                if (_managed is not null) { return _managed[i]; }
                return default;
            }
        }

        public SliceUtf8String(string[] managed)
        {
            _managed = managed;
        }

        public IEnumerator<string> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose() { }

        [CustomMarshaller(typeof(SliceUtf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;
        }

        public ref struct Marshaller
        {
            private SliceUtf8String _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceUtf8String managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public unsafe Unmanaged ToUnmanaged()
            {
                var size = sizeof(Utf8String.Unmanaged);
                _unmanaged = new Unmanaged();
                _unmanaged.Data = Marshal.AllocHGlobal(size * _managed.Count);
                _unmanaged.Len = (ulong) _managed.Count;
                for (var i = 0; i < _managed.Count; ++i)
                {
                    var _marshaller = new Utf8String.Marshaller();
                    _marshaller.FromManaged(new Utf8String(_managed._managed[i]));
                    var unmanaged = _marshaller.ToUnmanaged();
                    var dst = IntPtr.Add(_unmanaged.Data, i * size);
                    Marshal.StructureToPtr(unmanaged, dst, false);
                }
                return _unmanaged;
            }

            public unsafe SliceUtf8String ToManaged()
            {
                _managed = new SliceUtf8String();
                return _managed;
            }

            public void Free() { Marshal.FreeHGlobal(_unmanaged.Data); }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceVec
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceVec : IEnumerable<Vec>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<Vec> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe Vec this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<Vec>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<Vec>()));
            }

        }

        public SliceVec(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceVec(Vec[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<Vec> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceVec), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceVec ToManaged()
            {
                return new SliceVec(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceVec _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceVec managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceVec ToManaged()
            {
                _managed = new SliceVec();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceMutU32
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceMutU32 : IEnumerable<uint>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<uint> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe uint this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<uint>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<uint>()));
            }

            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                Unsafe.Write<uint>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<uint>()), value);
            }
        }

        public SliceMutU32(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceMutU32(uint[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<uint> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceMutU32), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceMutU32 ToManaged()
            {
                return new SliceMutU32(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceMutU32 _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceMutU32 managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceMutU32 ToManaged()
            {
                _managed = new SliceMutU32();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceMutU8
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceMutU8 : IEnumerable<byte>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<byte> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe byte this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()));
            }

            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                Unsafe.Write<byte>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<byte>()), value);
            }
        }

        public SliceMutU8(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceMutU8(byte[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceMutU8), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceMutU8 ToManaged()
            {
                return new SliceMutU8(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceMutU8 _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceMutU8 managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceMutU8 ToManaged()
            {
                _managed = new SliceMutU8();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_pattern_fast_slice 
    public partial struct SliceMutVec
    {
        GCHandle _handle;
        IntPtr _data;
        ulong _len;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct SliceMutVec : IEnumerable<Vec>, IDisposable
    {
        public int Count => (int) _len;

        public unsafe ReadOnlySpan<Vec> ReadOnlySpan
        {
            get => new(_data.ToPointer(), (int)_len);
        }

        public unsafe Vec this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                return Unsafe.Read<Vec>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<Vec>()));
            }

            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                Unsafe.Write<Vec>((void*)IntPtr.Add(_data, i * Unsafe.SizeOf<Vec>()), value);
            }
        }

        public SliceMutVec(IntPtr data, ulong len)
        {
            _data = data;
            _len = len;
        }

        public SliceMutVec(Vec[] managed)
        {
            _handle = GCHandle.Alloc(managed, GCHandleType.Pinned);
            _data = _handle.AddrOfPinnedObject();
            _len = (ulong) managed.Length;
        }

        public IEnumerator<Vec> GetEnumerator()
        {
            for (var i = 0; i < Count; ++i) { yield return this[i]; }
        }

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Dispose()
        {
            if (_handle is { IsAllocated: true }) { _handle.Free(); }
        }

        [CustomMarshaller(typeof(SliceMutVec), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            public IntPtr Data;
            public ulong Len;

            public SliceMutVec ToManaged()
            {
                return new SliceMutVec(Data, Len);
            }
        }

        public ref struct Marshaller
        {
            private SliceMutVec _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(SliceMutVec managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Data = _managed._data;
                _unmanaged.Len = _managed._len;
                return _unmanaged;
            }

            public unsafe SliceMutVec ToManaged()
            {
                _managed = new SliceMutVec();
                _managed._data = _unmanaged.Data;
                _managed._len = _unmanaged.Len;
                return _managed;
            }

            public void Free() { }
        }
    }

    // Debug - write_type_definition_composite 
    ///Option type containing boolean flag and maybe valid data.
    public partial struct OptionVec
    {
        ///Element that is maybe valid.
        Vec t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    // Debug - write_type_definition_composite_marshaller 
    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct OptionVec
    {
        public OptionVec(OptionVec other)
        {
            t = other.t;
            is_some = other.is_some;
        }

        public Unmanaged ToUnmanaged()
        {
            var marshaller = new Marshaller(this);
            try { return marshaller.ToUnmanaged(); }
            finally { marshaller.Free(); }
        }

        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            // Debug - write_type_definition_composite_unmanaged_body_field 
            public Vec.Unmanaged t;
            // Debug - write_type_definition_composite_unmanaged_body_field 
            public byte is_some;

            public OptionVec ToManaged()
            {
                var marshaller = new Marshaller(this);
                try { return marshaller.ToManaged(); }
                finally { marshaller.Free(); }
            }
        }

        [CustomMarshaller(typeof(OptionVec), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private OptionVec _managed; // Used when converting managed -> unmanaged
            private Unmanaged _unmanaged; // Used when converting unmanaged -> managed

            public Marshaller(OptionVec managed) { _managed = managed; }
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public void FromManaged(OptionVec managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public unsafe Unmanaged ToUnmanaged()
            {;
                _unmanaged = new Unmanaged();

                // Debug - write_type_definition_composite_marshaller_unmanaged_invoke 
                var _t = new Vec.Marshaller(_managed.t);
                _unmanaged.t = _t.ToUnmanaged();
                // Debug - write_type_definition_composite_marshaller_unmanaged_invoke 
                _unmanaged.is_some = _managed.is_some;

                return _unmanaged;
            }

            public unsafe OptionVec ToManaged()
            {
                _managed = new OptionVec();

                // Debug - write_type_definition_composite_marshaller_field_from_unmanaged 
                var _t = new Vec.Marshaller(_unmanaged.t);
                _managed.t = _t.ToManaged();
                // Debug - write_type_definition_composite_marshaller_field_from_unmanaged 
                _managed.is_some = _unmanaged.is_some;

                return _managed;
            }
            public void Free() { }
        }
    }

    // Debug - write_pattern_option 
    public partial struct OptionVec
    {
        public static OptionVec FromNullable(Vec? nullable)
        {
            var result = new OptionVec();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public Vec? ToNullable()
        {
            return this.is_some == 1 ? this.t : (Vec?)null;
        }
    }


    // Debug - write_type_definition_ffibool 
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Bool
    {
        byte value;
    }

    public partial struct Bool
    {
        public static readonly Bool True = new Bool { value =  1 };
        public static readonly Bool False = new Bool { value =  0 };
        public Bool(bool b)
        {
            value = (byte) (b ? 1 : 0);
        }
        public bool Is => value == 1;
    }


    // Debug - write_type_definition_named_callback 
    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate uint MyCallbackNamespacedNative(uint value, IntPtr callback_data); // 'True' native callback signature
    public delegate uint MyCallbackNamespacedDelegate(uint value); // Our C# signature

    public partial class MyCallbackNamespaced
    {
        private MyCallbackNamespacedDelegate _managed; // C# callback
        private MyCallbackNamespacedNative _native; // Native callback 
        private IntPtr _ptr; // Raw function pointer of native callback
        private Exception _exception; // Set if the callback encountered an Exception
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial class MyCallbackNamespaced : IDisposable
    {

        public MyCallbackNamespaced() { }

        public MyCallbackNamespaced(MyCallbackNamespacedDelegate managed)
        {
            _managed = managed;
            _native = CallTrampoline;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        // Helper to invoke managed code from the native invocation.
        private uint CallTrampoline(uint value, IntPtr callback_data)
        {
            // We ignore the last parameter, a generic callback pointer, as it's not needed in C#.
            try
            {
                return _managed(value);
            }
            catch (Exception e)
            {
                _exception = e;
                return default;
            }
        }

        // Invokes the callback.
        public uint Call(uint value)
        {
            var __target = Marshal.GetDelegateForFunctionPointer<MyCallbackNamespacedNative>(_ptr);
            // TODO
            // return __target(value);
            return default;
        }

        public void Dispose()
        {
            // This means when the callback was invoked from Rust C# had an exception which
            // we caught (otherwise C# might not re-enter Rust, and we leak memory). Now is
            // the time to rethrow it.
            if (_exception != null) throw _exception;
        }

        [CustomMarshaller(typeof(MyCallbackNamespaced), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta {  }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr Callback;
            internal IntPtr Data;
        }

        public ref struct Marshaller
        {
            private MyCallbackNamespaced _managed;
            private Unmanaged _unmanaged;

            public Marshaller(MyCallbackNamespaced managed) { _managed = managed; }
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public void FromManaged(MyCallbackNamespaced managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Callback = _managed?._ptr ?? IntPtr.Zero;
                _unmanaged.Data = IntPtr.Zero;
                return _unmanaged;
            }

            public MyCallbackNamespaced ToManaged()
            {
                _managed = new MyCallbackNamespaced();
                _managed._ptr = _unmanaged.Callback;
                return _managed;
            }

            public void Free() { }
        }
    }




    public class InteropException<T> : Exception
    {
        public T Error { get; private set; }

        public InteropException(T error): base($"Something went wrong: {error}")
        {
            Error = error;
        }
    }

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void AsyncHelperNative(IntPtr data, IntPtr callback_data);
    public delegate void AsyncHelperDelegate(IntPtr data);

    public partial struct AsyncHelper
    {
        private AsyncHelperDelegate _managed;
        private AsyncHelperNative _native;
        private IntPtr _ptr;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct AsyncHelper : IDisposable
    {
        public AsyncHelper() { }

        public AsyncHelper(AsyncHelperDelegate managed)
        {
            _managed = managed;
            _native = Call;
            _ptr = Marshal.GetFunctionPointerForDelegate(_native);
        }

        void Call(IntPtr data, IntPtr _)
        {
            _managed(data);
        }

        public void Dispose()
        {
            if (_ptr == IntPtr.Zero) return;
            Marshal.FreeHGlobal(_ptr);
            _ptr = IntPtr.Zero;
        }

        [CustomMarshaller(typeof(AsyncHelper), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        [StructLayout(LayoutKind.Sequential)]
        public struct Unmanaged
        {
            internal IntPtr Callback;
            internal IntPtr Data;
        }

        public ref struct Marshaller
        {
            private AsyncHelper _managed;
            private Unmanaged _unmanaged;

            public void FromManaged(AsyncHelper managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public Unmanaged ToUnmanaged()
            {
                _unmanaged = new Unmanaged();
                _unmanaged.Callback = _managed._ptr;
                _unmanaged.Data = IntPtr.Zero;
                return _unmanaged;
            }

            public AsyncHelper ToManaged()
            {
                _managed = new AsyncHelper();
                _managed._ptr = _unmanaged.Callback;
                return _managed;
            }

            public void Free() { }
        }
    }
    public partial struct Utf8String
    {
        string _s;
    }

    [NativeMarshalling(typeof(MarshallerMeta))]
    public partial struct Utf8String: IDisposable
    {
        public Utf8String(string s) { _s = s; }

        public string String => _s;

        public void Dispose() { }

        public Unmanaged ToUnmanaged()
        {
            var marshaller = new Marshaller(this);
            try { return marshaller.ToUnmanaged(); }
            finally { marshaller.Free(); }
        }

        /// A highly dangerous 'use once type' that has ownership semantics!
        /// Once passed over an FFI boundary 'the other side' is meant to own
        /// (and free) it. Rust handles that fine, but if in C# you put this
        /// in a struct and then call Rust multiple times with that struct
        /// you'll free the same pointer multiple times, and get UB!
        [StructLayout(LayoutKind.Sequential)]
        public unsafe struct Unmanaged
        {
            public IntPtr ptr;
            public ulong len;
            public ulong capacity;

            public string ToManaged()
            {
                var marshaller = new Marshaller(this);
                try { return marshaller.ToManaged().String; }
                finally { marshaller.Free(); }
            }

        }

        public partial class InteropHelper
        {
            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_create")]
            public static partial long interoptopus_string_create(IntPtr utf8, ulong len, out Unmanaged rval);

            [LibraryImport(Interop.NativeLib, EntryPoint = "interoptopus_string_destroy")]
            public static partial long interoptopus_string_destroy(Unmanaged utf8);
        }

        [CustomMarshaller(typeof(Utf8String), MarshalMode.Default, typeof(Marshaller))]
        private struct MarshallerMeta { }

        public ref struct Marshaller
        {
            private Utf8String _managed; // Used when converting managed -> unmanaged
            private Unmanaged _unmanaged; // Used when converting unmanaged -> managed

            public Marshaller(Utf8String managed) { _managed = managed; }
            public Marshaller(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public void FromManaged(Utf8String managed) { _managed = managed; }
            public void FromUnmanaged(Unmanaged unmanaged) { _unmanaged = unmanaged; }

            public unsafe Unmanaged ToUnmanaged()
            {
                var utf8Bytes = Encoding.UTF8.GetBytes(_managed._s);
                var len = utf8Bytes.Length;

                fixed (byte* p = utf8Bytes)
                {
                    InteropHelper.interoptopus_string_create((IntPtr)p, (ulong)len, out var rval);
                    _unmanaged = rval;
                }

                return _unmanaged;
            }

            public unsafe Utf8String ToManaged()
            {
                var span = new ReadOnlySpan<byte>((byte*)_unmanaged.ptr, (int)_unmanaged.len);

                _managed = new Utf8String();
                _managed._s = Encoding.UTF8.GetString(span);

                InteropHelper.interoptopus_string_destroy(_unmanaged);

                return _managed;
            }

            public void Free() { }
        }
    }

}
